## 声明响应式状态

使用[`reactive()`](https://staging-cn.vuejs.org/api/reactivity-core.html#reactive) 函数创建一个响应式对象或数组

```js
import { reactive } from 'vue'

const state = reactive({ count: 0 })
```


响应式对象其实是 [JavaScript Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为表现与一般对象相似。

```js

const obj = {count:0}

const proxyOBj = new Proxy(obj)

```
要在组件模板中使用响应式状态，请在 `setup()` 函数中定义并返回。

```js
import { reactive } from 'vue'

export default {
  // `setup` 是一个专门用于组合式 API 的特殊钩子
  setup() {
    const state = reactive({ count: 0 })

    // 暴露 state 到模板
    return {
      state
    }
  }
}
```

```html
<div>{{ state.count }}</div>
```

可直接定义方法
```js
import { reactive } from 'vue'

export default {
  setup() {
    const state = reactive({ count: 0 })

    function increment() {
      state.count++
    }

    // 不要忘记同时暴露 increment 函数
    return {
      state,
      increment
    }
  }
}
```

### DOM 更新时机
当你**更改响应式状态**后，DOM 也会自动更新。然而，你得注意 **DOM 的更新并不是同步**的






### `reactive()` 的局限性


`reactive()` API 有两条限制：

1.  仅对对象类型有效（对象、数组和 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E4%BD%BF%E7%94%A8%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1)），而对 `string`、`number` 和 `boolean` 这样的 [原始类型](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive) 无效。
2. 因为 Vue 的响应式系统是通过 property 访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地 “替换” 一个响应式对象：