## 函数定义

函数的两种定义方式

* 函数声明

  ```js
  function foo(x, y){
      return x + y;
  }
  //后面不加分号
  ```

  

* 函数表达式

  ```js
  let foo = function (x, y){
      return x + y;
  };
  //变量初始化赋值，结尾要加分号
  
  let foo = (x, y)=>{
      return x + y;
  };
  ```
  
* 使用Function构造函数

  ```js
  let sum = new Function("num1", "num2", "return num1 + num2"); 
  //不推荐
  ```

  理由：代码会被解释两次，第一次是将它当作常规 ECMAScript 代码，第二次是解释传给构造函数的字符串。

## 箭头函数

写法：

```js
let singleArgument = x =>  2*x;
//单个参数可以不加括号，没有{}的时候，可以不用加返回值，但是不能换行,省略大括号会隐式返回这行代码的值

let noArgument = () => {}
//

let doubleArgument = (x, y) => {return x+y};
//多参数必须加括号


```



特点：

* 自身没有this，arguments，super，prototype，new.target



## 函数名

* 函数名就是函数的指针，可以有多个名称

  ```js
  function sum(num1, num2) { 
   return num1 + num2; 
  } 
  console.log(sum(10, 10)); // 20 
  let anotherSum = sum; 
  console.log(anotherSum(10, 10)); // 20 
  sum = null; 
  console.log(anotherSum(10, 10)); // 20 
  ```

* 所有的函数都有一个只读的name属性，访问这个属性会显示具名函数的函数标识符

  ```js
  function foo() {} 
  let bar = function() {}; 
  let baz = () => {}; 
  console.log(foo.name); // foo 
  console.log(bar.name); // bar 
  console.log(baz.name); // baz 
  console.log((() => {}).name); //（空字符串）
  console.log((new Function()).name); // anonymous 
  ```

  * 如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：

    ```js
    function foo() {} 
    console.log(foo.bind(null).name); // bound foo 
    let dog = { 
     years: 1, 
     get age() { 
     return this.years; 
     }, 
     set age(newAge) { 
     this.years = newAge; 
     } 
    } 
    let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age'); 
    console.log(propertyDescriptor.get.name); // get age 
    console.log(propertyDescriptor.set.name); // set age
    ```

    ## 理解参数

* 函数参数接受个数跟定义个数可以不一致，也不会报错。**因为**

  ```js
  function foo(arguments){// arguments相当于占位符
      return arguments
  }
  
  
  
  foo()
  // Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]
  // callee: ƒ foo()
  // length: 0
  // Symbol(Symbol.iterator): ƒ values()
  // [[Prototype]]: Object
  
  foo(1,2,3)
  
  // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
  // 0: 1
  // 1: 2
  // 2: 3
  // callee: ƒ foo()
  // length: 3
  // Symbol(Symbol.iterator): ƒ values()
  // [[Prototype]]: Object
  ```

  ![image-20210823043835593](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823043835593.png)

![image-20210823044015506](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210823044015506.png)





## 箭头函数

* 如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只 能通过定义的命名参数访问

```js
function foo() { 
 console.log(arguments[0]); 
} 
foo(5); // 5


let bar = () => { 
 console.log(arguments[0]); 
}; 
bar(5); // ReferenceError: arguments is not defined 


function foo() { 
 let bar = () => { 
 console.log(arguments[0]); // 5 
 }; 
 bar(); 
} 
foo(5); 
```

ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作 为参数传递，那么传递的值就是这个对象的引用。

## 没有重载

* 如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。

```js
function addSomeNumber(num) { 
 return num + 100; 
} 
function addSomeNumber(num) { 
 return num + 200; 
} 
let result = addSomeNumber(100); // 300
```

* 把函数名当成指针也有助于理解为什么 ECMAScript 没有函数重载。





## 默认参数

* es5实现默认值

  ```js
  function makeKing(name) { 
   name = (typeof name !== 'undefined') ? name : 'Henry'; 
   return `King ${name} VIII`; 
  } 
  ```

* es6实现默认值

  ```js
  function makeKing(name = 'Henry') { 
   return `King ${name} VIII`; 
  } 
  ```

 * arguments 对象的值不反映参数的默认值，只反映传给函数的参数。就是说没有传递参数时，并不会显示实际参数的值，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准

    ```js
    function makeKing(name = 'Henry') { 
     name = 'Louis'; 
     return `King ${arguments[0]}`; 
    } 
    
    console.log(makeKing()); // 'King undefined' 
    console.log(makeKing('Louis')); // 'King Louis' 
    ```

  * 默认参数除了可以用原始值和普通对象，也可以用函数返回值

      ```js
      let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI']; 
      let ordinality = 0; 
      function getNumerals() { 
       // 每次调用后递增
       return romanNumerals[ordinality++]; 
      }
      
      function makeKing(name = 'Henry', numerals = getNumerals()) { 
       return `King ${name} ${numerals}`; 
      } 
      
      console.log(makeKing()); // 'King Henry I'
    console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI' 
    console.log(makeKing()); // 'King Henry II' 
    console.log(makeKing()); // 'King Henry III' 
    
    
    let makeKing = (name = 'Henry') => `King ${name}`; 
    console.log(makeKing()); // King Henry 
    ```
    
    > 注意：**函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。**
    >
    > **计算默认值的函数 只有在调用函数但未传相应参数时才会被调用。**

## 默认参数作用域与暂时性死区

* 因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。
* 参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。

```js
function makeKing(name = 'Henry', numerals = name) { 
 return `King ${name} ${numerals}`; 
} 
console.log(makeKing()); // King Henry Henry 

// 调用时不传第一个参数会报错
function makeKing(name = numerals, numerals = 'VIII') { 
 return `King ${name} ${numerals}`; 
} 
```





## 函数声明与函数表达式

* JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中 生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

  ```js
  // 没问题 
  console.log(sum(10, 10)); 
  function sum(num1, num2) { 
   return num1 + num2; 
  }
  
  
  // 会出错
  console.log(sum(10, 10)); 
  var sum = function(num1, num2) { 
   return num1 + num2; 
  }; 
  ```

  因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个 过程叫作函数声明提升（function declaration hoisting）。

  **这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义**





## 函数作为值

```js
//声明普通函数
function callSomeFunction(someFunction, someArgument) { 
 return someFunction(someArgument); 
} 

//声明回调函数
function add10(num) { 
 return num + 10; 
}

//执行
let result1 = callSomeFunction(add10, 10); 
console.log(result1); // 20 
```

记住`callSomeFunction(add10, 10)`传入的是函数，而不会函数调用，不然`return someFunction(someArgument)`会报错。





## 函数内部

在 ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和 this。ECMAScript 6 又新增 了 new.target 属性。

### arguments

概念：它是一个类数组对象，包含调用函数时传入的所有参数。

```js
function factorial(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * factorial(num - 1); 
 } 
} 
```

#### arguments.callee

概念：用于引用该函数的函数体内当前正在执行的函数。

```js
function factorial(num) { 
 onsole.log(arguments.callee === factorial); //true
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * arguments.callee(num - 1); //根据传入的arguments，获取其所在的函数
 } 
}
```

这意味着无论函数叫什么名称，都可以引用正确的函数。



### this

this 引用的是把函数当成方法调用的上下文对象。

```js
window.color = 'red'; 
let o = { 
 color: 'blue' 
}; 
function sayColor() { 
 console.log(this.color); 
} 
sayColor(); // 'red' 
o.sayColor = sayColor; 
o.sayColor(); // 'blue' 
```

在箭头函数中，this引用的是定义箭头函数的上下文。

```js
window.color = 'red'; 
let o = { 
 color: 'blue' 
}; 
let sayColor = () => console.log(this.color); 
sayColor(); // 'red' 
o.sayColor = sayColor; 
o.sayColor(); // 'red' 
```

> 函数名只是保存指针的变量。因此全局定义的 sayColor()函数和 o.sayColor() 是同一个函数，只不过执行的上下文不同。

箭头函数自身没有this，默认指向全局对象。

```js
function King() { 
 this.royaltyName = 'Henry'; 
 // this 引用 King 的实例
 setTimeout(() => console.log(this.royaltyName), 1000); 
}

function Queen() { 
 this.royaltyName = 'Elizabeth'; 
 // this 引用 window 对象
 setTimeout(function() { console.log(this.royaltyName); }, 1000); 
} 
let king = new King(); // Henry 
let queen = new Queen(); // undefined
```

这里使用了普通函数和箭头函数，执行`new King()`，首先会生成一个空对象，然后这个对象的`_proto_`绑定`King.prototype`,`this`绑定这个对象，最后返回这个对象。

当同步执行完，最后执行`setTimeout`的回调函数，`setTimeout`接收一个回调，这个回调如果是普通函数，会根据调用的对象确定`this`的值。

如果回调函数是箭头函数，由于自身没有`this`，会根据定义函数的作用域链寻找最近的this

**Queen正确书写方式**

```js
function Queen() { 
 this.royaltyName = 'Elizabeth'; 
 // this 引用 window 对象
 setTimeout(function fn() { console.log(this.royaltyName); }, 1000); 
} 

let queen = new Queen();
//相当于
queen.Queen()
fn()//这里是最后执行的，所以没有对象调用，结果为undefined
```

**King正确书写方式**

```js
function King() { 
 this.royaltyName = 'Henry'; 
 // this 引用 King 的实例
 setTimeout( let fn = () => console.log(this.royaltyName), 1000); 
}

let king = new King();
//相当于
king.King()
King.fn() //这里fn，会根据作用域链寻找最近的function定义的函数，获取this
```

### caller

返回调用指定函数的函数.

```js
function outer() { 
 inner(); 
} 
function inner() { 
 console.log(inner.caller); 
} 
outer(); 

//mdn的解释
function myFunc() {
   if (myFunc.caller == null) {
      return ("该函数在全局作用域内被调用!");
   } else
      return ("调用我的是函数是" + myFunc.caller);
}
```

会显示 outer()函数的源代码。

```js
function outer() { 
 inner(); 
} 
function inner() { 
 console.log(arguments.callee.caller); 
} 
outer(); 
```

在严格模式下访问 arguments.callee 会报错。ECMAScript 5 也定义了 arguments.caller，但 在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller 和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同 一上下文中运行的其他代码。 严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误



### new.target

**`new.target`**属性允许你检测函数或构造方法是否是通过[new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)运算符被调用的

```js
function Foo() {
  if (!new.target) throw "Foo() must be called with new";
  console.log("Foo instantiated with new");
}

Foo(); // throws "Foo() must be called with new"
new Foo(); // logs "Foo instantiated with new"
```



## 函数属性与方法

ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length 和 prototype。

* length 属性查找对象的形参个数

  ```js
  function sayName(name) { 
   console.log(name); 
  } 
  function sum(num1, num2) { 
   return num1 + num2; 
  } 
  function sayHi() { 
   console.log("hi"); 
  } 
  console.log(sayName.length); // 1 
  console.log(sum.length); // 2 
  console.log(sayHi.length); // 0
  ```

* prototype 是保存引用类型所有实例 方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享。
* prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。
* apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设 置调用函数时函数体内 this 对象的值。
* apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。

```js
function sum(num1, num2) { 
 return num1 + num2; 
} 
function callSum1(num1, num2) { 
 return sum.apply(this, arguments); // 传入 arguments 对象
}

function callSum2(num1, num2) { 
 return sum.apply(this, [num1, num2]); // 传入数组
} 
console.log(callSum1(10, 10)); // 20 
console.log(callSum2(10, 10)); // 20
```

> 在严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。 除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。

* call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须 将参数一个一个地列出来.

  ```js
  function sum(num1, num2) { 
   return num1 + num2; 
  } 
  
  function callSum(num1, num2) { 
   return sum.call(this, num1, num2); 
  } 
  
  console.log(callSum(10, 10)); // 20 
  ```

  **如果想直接传 arguments 对象或者一个数组，那就用 apply()；否则，就用 call()。**

* bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。

  ```js
  window.color = 'red'; 
  var o = { 
   color: 'blue' 
  }; 
  function sayColor() { 
   console.log(this.color); 
  } 
  let objectSayColor = sayColor.bind(o); 
  objectSayColor(); // blue 
  ```

  * 对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码。
  * 推荐继承的方法 **`valueOf()`**返回函数本身。

## 函数表达式

**函数声明**

```js
function foo() {
    
}
```

**函数表达式**

```js
const foo = function() {
    
}
```

> 区别：函数声明会提升,函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。

```js
sayHi(); 
function sayHi() { 
 console.log("Hi!"); 
}

sayHi(); // Error! function doesn't exist yet 
let sayHi = function() { 
 console.log("Hi!"); 
}; 
```





错误写法

```js
if (condition) { 
 function sayHi() { 
 console.log('Hi!'); 
 } 
} else { 
 function sayHi() { 
 console.log('Yo!'); 
 } 
} 
```

>  原因:由于函数声明的作用域跟var一样，只有全局和函数，这里由于变量提升和函数重名覆盖，无论`condition`为`true`还是`false`，结果都是`'Yo!'`

正确写法

```js
let sayHi; 
if (condition) { 
 sayHi = function() { 
 console.log("Hi!"); 
 }; 
} else { 
 sayHi = function() { 
 console.log("Yo!"); 
 }; 
}  
```

## 递归

递归函数通常的形式是一个函数通过名称调用自己

```js
function factorial(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * factorial(num - 1); 
 } 
} 

let anotherFactorial = factorial; 
factorial = null; 
console.log(anotherFactorial(4)); // 报错
```

> 由于`factorial = null; `,所以无法执行`  num * factorial(num - 1); `
>
> 

改正

```js
function factorial(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * arguments.callee(num - 1); 
 } 
} 
```

不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。

再改

```js
const factorial = (function f(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * f(num - 1); 
 } 
}); 

```





## 闭包



