## 理解对象

早年创建对象的方式

```js
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
person.job = "Software Engineer"; 
person.sayName = function() { 
 console.log(this.name); 
}; 
```

后面流行的字面量

```js
let person = { 
 name: "Nicholas", 
 age: 29, 
 job: "Software Engineer", 
 sayName() { 
 console.log(this.name); 
 } 
}; 
```

### 属性类型

ECMA-262 使用一些内部特性来描述属性的特征。

属性分两种：**数据属性**和**访问器属性**

****

### 数据属性

数据属性有 4 个特性描述它们的行为

* [[Configurable]]：表示属性是否可以修改数据属性值。默认为true
* [[Enumerable]]：表示属性是否可以通过 for-in 循环返回，也就是是否可以遍历。默认为true
* [[Writable]]：决定了目标属性的值（value）是否可以被改变。
* [[Value]]：包含属性实际的值。



[Object.defineProperties()]([Object.defineProperties() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties))

允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象

`Object.defineProperty`方法接受三个参数，依次如下。

- object：属性所在的对象
- propertyName：字符串，表示属性名
- attributesObject：属性描述对象

```js
let bokk = {
}

 Object.defineProperty(book, 'year', {
  value:2020,
  writable: false,
  enumerable: true,
  configurable: false
});

book.year // 2020

book.year = 2021;
book.year // 2020
```

###  访问器属性

访问器属性不包含数据值。但是它包含：获取（getter）函数和设置（setter）函数

访问器属性有 4 个特性描述它们的行为

* [[Configurable]]：跟数据属性一致
* [[Enumerable]]：跟数据属性一致
* [[Get]]：获取函数，在读取属性时调用。
* [[Set]]：设置函数，在写入属性时调用。

访问器属性是不能直接定义的，必须使用 Object.defineProperty()。

```js
let bokk = {
  year_: 2020, 
  edition: 1 
}

 Object.defineProperty(book, 'year', {
      get() { 
 return this.year_; 
 }, 
      set(newValue) { 
 if (newValue > 2020) { 
 this.year_ = newValue; 
 this.edition += newValue - 2020; 
 } 
 }},
  writable: false,
  enumerable: true,
  configurable: false
});

book.year = 2021;
console.log(book.edition);
```







### 合并对象

### （mixin）





### 创建对象



#### 工厂模式

工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。

```js
function createPerson(name, age, job) { 
 let o = new Object(); 
 o.name = name; 
 o.age = age; 
 o.job = job; 
 o.sayName = function() { 
 console.log(this.name); 
 }; 
 return o; 
} 
let person1 = createPerson("Nicholas", 29, "Software Engineer"); 
let person2 = createPerson("Greg", 27, "Doctor");
```

#### 构造函数模式

```js
function Person(name, age, job){ 
 this.name = name; 
 this.age = age; 
 this.job = job; 
 this.sayName = function() { 
 console.log(this.name); 
 }; 
} 
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 
person1.sayName(); // Nicholas 
person2.sayName(); // Greg 
```

和工厂模式的区别：

* 没有显式地创建对象。
* 属性和方法直接赋值给了 this
* 没有 return

主要原因是使用了 new操作符



**new干了什么**

1. 在内存中创建一个新对象
2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）
4. 执行构造函数内部的代码（给新对象添加属性）
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。





##### 构造函数也是函数

任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操 作符调用的函数就是普通函数。

##### 构造函数的问题

造函数的主要问题在于，其定义的方法会在每个实例上 都创建一遍。

```js
function Person() { 
 this.name = "Jake"; 
 this.sayName = function() { 
 console.log(this.name); 
 }; 
} 
let person1 = new Person(); 
let person2 = new Person; 

console.log(person1.sayName == person2.sayName); // false
```

#### 原型模式

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例 共享的属性和方法。

##### 理解原型

* 每个函数都有`prototype`（原型对象）这个属性

* 所有原型对象都有`constructor`属性，指向其构造函数`Person.prototype.constructor === Person`，`__proto__`，指向其原型`Object`,`Person.prototype.__proto__ === Object.prototype`

  Object.create()

```js
let biped = { 
 numLegs: 2 
}; 
let person = Object.create(biped); 
person.name = 'Matt'; 

console.log(person.__proto__ === biped) //true
```



## 继承

继承分两种：接口继承和实现继承，实现继承是 ECMAScript 唯一支持的继承方式

### 原型链

基本思想：通过原型链继承多个方法和属性



#### 默认原型

Object.prototype：所有原型的原型都是`Object.prototype`，



#### 原型与继承

原型与实例的关系可以通过两种方式来确定

instanceof

```js
console.log(instance instanceof Object); // true
```

isPrototypeOf()

```js
console.log(Object.prototype.isPrototypeOf(instance)); // true
```







#### 原型链



传递参数

```js
```









## 类

和函数声明区别：

* 类声明不能提升
* 类受块作用域限制

注意：**类名的首字母要大写**







#### 类构造函数



#### 把类当成特殊函数

```js
class Person{} 
console.log(Person.prototype); // { constructor: f() } 
console.log(Person === Person.prototype.constructor); // true 
```



类本身在使用 new 调用时就 会被当成构造函数,类中定义的 constructor 方法不会被当成构造函数，在对它使用 instanceof 操作符时会返回 false。

```js
class Person {} 
let p1 = new Person(); 
console.log(p1.constructor === Person); // true 
console.log(p1 instanceof Person); // true 
console.log(p1 instanceof Person.constructor); // false 
let p2 = new Person.constructor(); 
console.log(p2.constructor === Person); // false 
console.log(p2 instanceof Person); // false 
console.log(p2 instanceof Person.constructor); // true 
```



类是 JavaScript 的[一等公民](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#%E4%B8%BA%E4%BD%95%E9%92%9F%E7%88%B1%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91)，因此可以像其他对象或函数引用一样把类作为参数传递

