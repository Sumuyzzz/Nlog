### 什么是执行上下文

执行上下文是**评估和执行 JavaScript 代码的环境的抽象概念**。

每当JavaScript代码在运行时，都是在执行上下文中运行

### 类型
* 全局执行上下文：默认的上下文，任何不在函数内部的代码都在全局上下文中
* 函数执行上下文：每当函数调用时，就会为该函数，创建上下文。每个函数都有自己的上下文，每当函数上下文被创建时，都会以定义顺序执行。
* Eval上下文：一个内部自身执行上下文的函数，一般不讨论。

### 什么是执行栈
执行栈，也就是调用栈，用来存储代码运行时创建的所有执行上下文。

### 怎么创建执行上下文？

创建执行上下文有两个阶段：**1) 创建阶段** 和 **2) 执行阶段**。

#### The Creation Phase

在创建阶段会发生三件事：

1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建[[词法环境]]组件。
3. 创建[[变量环境]]组件。

所以执行上下文在概念上表示如下：

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

### **This 绑定：**

在全局执行上下文中，`this` 的值指向全局对象。(在浏览器中，`this`引用 Window 对象)。

在函数执行上下文中，`this` 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 `this` 会被设置成那个对象，否则 `this` 的值被设置为全局对象或者 `undefined`（在严格模式下）。

```js
let foo = {
  baz: function() {
  console.log(this);
  }
}

foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被
             // 对象 'foo' 调用

let bar = foo.baz;

bar();       // 'this' 指向全局 window 对象，因为
             // 没有指定引用对象

```











#### 变量提升

在代码的编译期间，即代码真正执行的瞬息之间，引擎会将代码块中所有的变量声明和函数声明都记录下来。这些函数声明和变量声明都会被记录在一个名为**词法环境**的数据结构中。词法环境是Javascript引擎中一种记录变量和函数声明的数据结构，它会被直接保存在内存中。

**变量提升的原因**：在创建阶段，函数声明存储在环境中，而变量会被设置为 `undefined`（在 `var` 的情况下）或保持未初始化（在 `let` 和 `const` 的情况下）。所以这就是为什么可以在声明之前访问 `var` 定义的变量（尽管是 `undefined` ），但如果在声明之前访问 `let` 和 `const` 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。













### 变量提升和函数提升

```js
foo();  // foo2
var foo = function() {
    console.log('foo1');
}

foo();  // foo1，foo重新赋值

function foo() {
    console.log('foo2');
}

foo(); // foo1
```





实际上的顺序

```js
var foo;
function foo(){
     console.log('foo2');
}
 foo();  // foo2
 foo = function() {
    console.log('foo1');
}
foo();  // foo1，foo重新赋值
foo(); // foo1
```



用执行上下文来看

```js
GlobalExectionContext = {
     ThisBinding: <Global Object>,
     LexicalEnvironment: {  
     EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
     foo: < func >  
      }  
    outer: <null>  
  },
     VariableEnvironment: {  
     EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里  
      foo: undefined,  
      }  
    outer: <null>  
  }  
    
   FunctionExectionContext = {  
         ThisBinding: <Global Object>,
        LexicalEnvironment: {  
       EnvironmentRecord: {  
      Type: "Declarative",  
         Arguments: {}, 
          },  
    outer: <GlobalLexicalEnvironment>  
  },
       VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
    },  
    outer: <GlobalLexicalEnvironment>  
  }  
}
```

