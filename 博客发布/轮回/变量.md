![image-20210624184945236](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210624184945236.png)



### 存在变量提升

```js
console.log(name); //undefined
var name = "sumuy";

//等同于
var name;
console.log(name);//undefined
name = "sumuy"
```











### 全局作用域

用来计数的循环变量泄露为全局变量。

```javascript
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

### 函数作用域

内层变量可能会覆盖外层变量。

```js
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```





## let

规则:

* 不存在变量提升
* 暂时性死区
* 不允许重复声明
* 只在声明所在的块级作用域内有效







### 不存在变量提升

```js
console.log(name); //name is not defined
let name = "sumuy"; 
```



### 暂时性死区

```js
name = "sumuy";

let name;
console.log(name) //Cannot access 'name' before initialization
```

### 不允许重复声明

```js
let name="sumuy"
let name="foo" // Identifier 'name' has already been declared
```

### 块级作用域

`let`实际上为 JavaScript 新增了块级作用域

```js
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

ES6 允许块级作用域的任意嵌套。

```javascript
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
```

## const

规则:

* 一旦声明不能修改
* 声明时候要立即赋值
* 只在声明所在的块级作用域内有效
* 不存在变量提升
* 不允许重复声明

### 一旦声明无法修改

```js
const name = "sumuy"
name="snwny" //Assignment to constant variable.
```

const虽然不允许修改绑定,但可以修改其值

```js
const obj={
    value:1
}
obj.value=2 //没问题

obj={} //Assignment to constant variable.
```









### 声明时候要立即赋值

```js
const foo; //Missing initializer in const declaration
```



### 只在声明所在的块级作用域内有效

```js
{
    const foo="foo"
}

```





### 块级作用域







ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。