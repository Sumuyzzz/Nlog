## 区别



| Keyword                                                      | Scope          | Hoisting | Can Be Reassigned | Can Be Redeclared |
| ------------------------------------------------------------ | -------------- | -------- | ----------------- | ----------------- |
| [`var`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var) | Function scope | Yes      | Yes               | Yes               |
| [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) | Block scope    | No       | Yes               | No                |
| [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) | Block scope    | No       | No                | No                |

## 关于变量优先级

```javascript
function Foo() {
  getName = function () {
    console.log(1)
  }
  return this
}
Foo.getName = function () {
  console.log(2)
}
Foo.prototype.getName = function () {
  console.log(3)
}
var getName = function () {
  console.log(4)
}
function getName() {
  console.log(5)
}

Foo.getName()  //2
getName()  // 
Foo().getName()  // 2
new Foo.getName()  // 3
new Foo().getName()  // 1
```

这道题目前三项很好蒙,但是后两项错了,就因为不懂变量的执行顺序

后面通过查资料看到了点思路

```javascript
function Foo() {
    getName = function () {     // [A]
        console.log(1)
    }
    return this
}
function getName() {     // [B]
  console.log(5)
}
var getName = undefined     // [C]
Foo.getName = function () {     // [D]
  console.log(2)
}
Foo.prototype.getName = function () {     // [E]
  console.log(3)
}
getName = function () {     // [F]
  console.log(4)
}
```

看到这里应该知道为什么`new Foo().getName()`不是5了吧

js 变量提升中，函数声明的优先级是高于函数表达式，而函数表达式的变量提升，是先将变量（此处是getName）提升并初始化为undefined，然后在代码执行到该函数表达式的时候再赋值（与var 定义变量情况相同）**但**，需要注意的是：

**函数的优先级要高于变量，且不会被变量的声明给覆盖，但会被后面变量的赋值给覆盖**

****



接下来解释一下输出值的问题

#### `Foo.getName()`

Foo是构造函数，上面 [D] 处定义了构造函数的静态方法，因此 Foo.getName() 的输出为 **2**

#### `getName()`

getName() 方法就看代码执行顺序，如果没有注意到 **[B] 已经提升** 至代码前面的话，这题很容易出错，以为是 5 ，顺序调整过来后，很容易就可以看出 getName 在 [F] 处已经重新赋值，覆盖掉之前的值，因此这里输出 **4**

#### `Foo().getName()`

Foo().getName() 先执行了构造函数，由于 Foo() 的 getName 方法没有使用 var 定义，因此 getName 是全局变量，[A] 处覆盖全局的 getName，因此输出 **1**

#### `new Foo.getName()`

这里需要先比较一下运算符的优先级，因点运算法优先级高于 new 运算符，因此相当于是new (Foo.getName)()，实际上将getName函数作为了构造函数来执行，因此输出 **2**

#### `new Foo().getName()`

这里同样需要先比较一下运算符的优先级，圆括号的优先级高于new，因此是 (new Foo()).getName()。new Foo() 实际返回的是 Foo 的实例，当实例上没有 getName 方法时，回去访问原型链上的 getName 方法，因此这里执行的是 [E] 处，因此输出 **3**



















### strict模式

如果都不用`var`申明，恰好都使用了变量`i`，将造成变量`i`互相影响，产生难以调试的错误结果。

使用`var`申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。

为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过`var`申明变量，未使用`var`申明变量就使用的，将导致运行错误。

