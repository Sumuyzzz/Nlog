# 对象

## 1 对象是什么

1. 对象是单个实物的抽象
2. 对象是一个容器,封装了属性和方法



## 2 构造函数

javascript使用构造函数作为对象的模板,所谓的构造函数就是用来生成实例对象的函数,它就是对象的模板.

###### 特点: 

* 函数体内使用了this关键字,代表了所要生成的实例
* 生成对象的时候,必须使用new命令



```javascript
// 推荐的写法
var v = new Vehicle();
// 不推荐的写法
var v = new Vehicle;
```

### new 命令的原理



使用`new`命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的`prototype`属性。
3. 将这个空对象赋值给函数内部的`this`关键字。
4. 开始执行构造函数内部的代码。









访问属性是通过`.`操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用`''`括起来：

``` js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```



要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```







如果属性的值还是一个对象，就形成了链式引用。

```
var o1 = {};
var o2 = { bar: 'hello' };

o1.foo = o2;
o1.foo.bar // "hello"
```

上面代码中，对象`o1`的属性`foo`指向对象`o2`，就可以链式引用`o2`的属性。

### 表达式还是语句？

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？

```
{ foo: 123 }
```

JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含`foo`属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签`foo`，指向表达式`123`。

为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。

```
{ console.log(123) } // 123
```

上面的语句是一个代码块，而且只有解释为代码块，才能执行。

如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

```
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
```

这种差异在`eval`语句（作用是对字符串求值）中反映得最明显。

```
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```

上面代码中，如果没有圆括号，`eval`将其理解为一个代码块；加上圆括号以后，就理解成一个对象。

## 属性读取

请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。

```
var foo = 'bar';

var obj = {
  foo: 1,
  bar: 2
};

obj.foo  // 1
obj[foo]  // 2
```

上面代码中，引用对象`obj`的`foo`属性时，如果使用点运算符，`foo`就是字符串；如果使用方括号运算符，但是不使用引号，那么`foo`就是一个变量，指向字符串`bar`。









**对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。**

````javascript
var obj = {
    name:'hah',
    age:18
}
````

一个大括号定义了一个对象，赋值给`obj`变量，所以变量`obj`就指向一个对象，对象内部包含两个成员，`name`对应的是**键名**，`hah`对应的是**键值**，键名与键值之间用冒号分隔。两个键值对之间用逗号分隔。

## 对象的两种声明方式

`let obj={p:'xxx'}`

`let obj = new Object({p:'xxx'})`



## 关于键名（属性）

> **对象的所有键名必须都是字符串**。**如果键名是数值，会被自动转为字符串。**

````javascript
var a ='xxx'
var obj = {
    [a] = 1
}
````

如果想引用变量名`a`作为键名，则使用方括号来引用`a`。

现在`obj`的属性就是变量`a`的值

***

> 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。

```js
var obj = {
  p: function (x) {
    return 2 * x;
  }
};
obj.p(1)//2
```

上面代码中，对象`obj`的属性`p`，就指向一个函数。

***

> 如果属性的值还是一个对象，就形成了链式引用。

```
var o1 = {};
var o2 = { bar: 'hello' };

o1.foo = o2;
o1.foo.bar // "hello"
```

上面代码中，对象`o1`的属性`foo`指向对象`o2`，就可以链式引用`o2`的属性。

***

> 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。

```
var obj = {
  p: 123,
  m: function () { ... },
}
```

上面的代码中，`m`属性后面的那个逗号，有没有都可以。

***

> 属性可以动态创建，不必在对象声明时就指定。

```
var obj = {};
obj.foo = 123;
obj.foo // 123
```

上面代码中，直接对`obj`对象的`foo`属性赋值，结果就在运行时创建了`foo`属性。

***

> 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。

```js
// 报错
var obj = {
  1p: 'Hello World'
};

// 不报错
var obj = {
  '1p': 'Hello World',
  'h w': 'Hello World',
  'p+q': 'Hello World'
};
```

### 表达式还是语句？

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？

```javascript
{ foo: 123 }
```

JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含`foo`属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签`foo`，指向表达式`123`。

## 语句还是表达式

为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。

```javascript
{ console.log(123) } // 123
```

上面的语句是一个代码块，而且只有解释为代码块，才能执行。

如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

```javascript
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
```

这种差异在`eval`语句（作用是对字符串求值）中反映得最明显。

```javascript
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```

上面代码中，如果没有圆括号，`eval`将其理解为一个代码块；加上圆括号以后，就理解成一个对象。

## 属性的操作

### 读取属性

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```javascript
var obj = {
  p: 'Hello World'
};

obj.p // "Hello World"
obj['p'] // "Hello World"
```



**注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。**



### 属性赋值

```javascript
var a = 1
var obj = {}
obj[a] = 1 // 1 : 1
obj['a'] = a // a : 1

```

**注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。如果键名不是字符，则先**

#### 多重赋值

```javascript
var obj = {}
Object.assign(obj,{
    p1:1,
    p2:2,
    p3:3
})//
```

使用`assign`函数能实现多重赋值

#### 修改隐藏属性

使用Object.create

```javascript
let obj = Object.create(common)
obj.name = 'frank'
let obj2 = Object.create(common)
Obj2.name ='jack'
```

规范大概的意思是，要改就开始改，别后来自改

### 删除属性 

`delete`命令用于删除对象的属性，删除成功后返回`true`。

````javascript
var obj = {p:'xxx'}
Object.keys(obj) // ["p"]

delete obj.p // true
obj.p // undefined
Object.keys(obj) // []
````

只有一种情况，`delete`命令会返回`false`，那就是该属性存在，且不得删除。

```
var obj = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

obj.p // 123
delete obj.p // false
```

上面代码之中，对象`obj`的`p`属性是不能删除的，所以`delete`命令返回`false`（关于`Object.defineProperty`方法的介绍，请看《标准库》的 Object 对象一章）。

### 查看属性

````javascript
var obj = {
  key1: 1,
  key2: 2
};

Object.keys(obj);// ['key1', 'key2']
````

#### in运算符

`in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象。

```
var obj = { p: 1 };
'p' in obj // true
'toString' in obj // true
```

`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象`obj`本身并没有`toString`属性，但是`in`运算符会返回`true`，因为这个属性是继承的。

使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。

```js
var obj = {};
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString')) // false
}
```











拷贝：开辟一个新的对象，将源对象的属性拷贝进来

* 浅拷贝：第一层引用地址不同，其余相同
* 深拷贝：所有的引用地址都是新开辟的，



赋值：复制引用地址