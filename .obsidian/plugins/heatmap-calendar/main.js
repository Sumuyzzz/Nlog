/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => HeatmapCalendar
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  year: new Date().getFullYear(),
  colors: {
    default: ["#c6e48b", "#7bc96f", "#49af5d", "#2e8840", "#196127"]
  },
  entries: [{ date: "1900-01-01" }],
  showCurrentDayBorder: true,
  defaultEntryIntensity: 4,
  intensityScaleStart: 1,
  intensityScaleEnd: 5
};
var HeatmapCalendar = class extends import_obsidian.Plugin {
  getHowManyDaysIntoYear(date) {
    return (Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()) - Date.UTC(date.getUTCFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
  }
  getHowManyDaysIntoYearLocal(date) {
    return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
  }
  removeHtmlElementsNotInYear(entries, year) {
    var _a;
    const calEntriesNotInDisplayedYear = (_a = entries.filter((e) => Number.parseInt(e.date.substring(0, 10)) !== year)) != null ? _a : this.settings.entries;
    calEntriesNotInDisplayedYear.forEach((e) => e.content instanceof HTMLElement && e.content.remove());
  }
  clamp(input, min, max) {
    return input < min ? min : input > max ? max : input;
  }
  map(current, inMin, inMax, outMin, outMax) {
    const mapped = (current - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    return this.clamp(mapped, outMin, outMax);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      window.renderHeatmapCalendar = (el, calendarData) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const year = (_a = calendarData.year) != null ? _a : this.settings.year;
        const colors = (_b = calendarData.colors) != null ? _b : this.settings.colors;
        this.removeHtmlElementsNotInYear(calendarData.entries, year);
        const calEntries = (_c = calendarData.entries.filter((e) => Number.parseInt(e.date.substring(0, 10)) === year)) != null ? _c : this.settings.entries;
        const showCurrentDayBorder = (_d = calendarData.showCurrentDayBorder) != null ? _d : this.settings.showCurrentDayBorder;
        const defaultEntryIntensity = (_e = calendarData.defaultEntryIntensity) != null ? _e : this.settings.defaultEntryIntensity;
        const intensities = calEntries.filter((e) => e.intensity).map((e) => e.intensity);
        const minimumIntensity = intensities.length ? Math.min(...intensities) : this.settings.intensityScaleStart;
        const maximumIntensity = intensities.length ? Math.max(...intensities) : this.settings.intensityScaleEnd;
        const intensityScaleStart = (_f = calendarData.intensityScaleStart) != null ? _f : minimumIntensity;
        const intensityScaleEnd = (_g = calendarData.intensityScaleEnd) != null ? _g : maximumIntensity;
        const mappedEntries = [];
        calEntries.forEach((e) => {
          var _a2;
          const newEntry = __spreadValues({
            intensity: defaultEntryIntensity
          }, e);
          const colorIntensities = (_a2 = colors[e.color]) != null ? _a2 : colors[Object.keys(colors)[0]];
          const numOfColorIntensities = Object.keys(colorIntensities).length;
          newEntry.intensity = Math.round(this.map(newEntry.intensity, intensityScaleStart, intensityScaleEnd, 1, numOfColorIntensities));
          mappedEntries[this.getHowManyDaysIntoYear(new Date(e.date))] = newEntry;
        });
        const firstDayOfYear = new Date(Date.UTC(year, 0, 1));
        let numberOfEmptyDaysBeforeYearBegins = (firstDayOfYear.getUTCDay() + 6) % 7;
        const boxes = [];
        while (numberOfEmptyDaysBeforeYearBegins) {
          boxes.push({ backgroundColor: "transparent" });
          numberOfEmptyDaysBeforeYearBegins--;
        }
        const lastDayOfYear = new Date(Date.UTC(year, 11, 31));
        const numberOfDaysInYear = this.getHowManyDaysIntoYear(lastDayOfYear);
        const todaysDayNumberLocal = this.getHowManyDaysIntoYearLocal(new Date());
        for (let day = 1; day <= numberOfDaysInYear; day++) {
          const box = {};
          if (day === todaysDayNumberLocal && showCurrentDayBorder)
            box.classNames = "today";
          if (mappedEntries[day]) {
            const entry = mappedEntries[day];
            box.date = entry.date;
            if (entry.content)
              box.content = entry.content;
            const currentDayColors = entry.color ? colors[entry.color] : colors[Object.keys(colors)[0]];
            box.backgroundColor = currentDayColors[entry.intensity - 1];
          }
          boxes.push(box);
        }
        const heatmapCalendarGraphDiv = createDiv({
          cls: "heatmap-calendar-graph",
          parent: el
        });
        createDiv({
          cls: "heatmap-calendar-year",
          text: String(year).slice(2),
          parent: heatmapCalendarGraphDiv
        });
        const heatmapCalendarMonthsUl = createEl("ul", {
          cls: "heatmap-calendar-months",
          parent: heatmapCalendarGraphDiv
        });
        createEl("li", { text: "Jan", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Feb", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Mar", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Apr", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "May", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Jun", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Jul", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Aug", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Sep", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Oct", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Nov", parent: heatmapCalendarMonthsUl });
        createEl("li", { text: "Dec", parent: heatmapCalendarMonthsUl });
        const heatmapCalendarDaysUl = createEl("ul", {
          cls: "heatmap-calendar-days",
          parent: heatmapCalendarGraphDiv
        });
        createEl("li", { text: "Mon", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Tue", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Wed", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Thu", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Fri", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Sat", parent: heatmapCalendarDaysUl });
        createEl("li", { text: "Sun", parent: heatmapCalendarDaysUl });
        const heatmapCalendarBoxesUl = createEl("ul", {
          cls: "heatmap-calendar-boxes",
          parent: heatmapCalendarGraphDiv
        });
        boxes.forEach((e) => {
          createEl("li", {
            text: e.content,
            attr: __spreadValues({}, e.backgroundColor && { style: `background-color: ${e.backgroundColor};` }),
            cls: e.classNames,
            parent: heatmapCalendarBoxesUl
          });
        });
      };
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCB9IGZyb20gJ29ic2lkaWFuJ1xyXG5cclxuaW50ZXJmYWNlIENhbGVuZGFyRGF0YSB7XHJcblx0eWVhcjogbnVtYmVyXHJcblx0Y29sb3JzOiB7XHJcblx0XHRbaW5kZXg6IHN0cmluZyB8IG51bWJlcl06IHtcclxuXHRcdFx0W2luZGV4OiBudW1iZXJdOiBzdHJpbmdcclxuXHRcdH1cclxuXHR9XHJcblx0ZW50cmllczogRW50cnlbXVxyXG5cdHNob3dDdXJyZW50RGF5Qm9yZGVyOiBib29sZWFuXHJcblx0ZGVmYXVsdEVudHJ5SW50ZW5zaXR5OiBudW1iZXJcclxuXHRpbnRlbnNpdHlTY2FsZVN0YXJ0OiBudW1iZXJcclxuXHRpbnRlbnNpdHlTY2FsZUVuZDogbnVtYmVyXHJcbn1cclxuaW50ZXJmYWNlIEVudHJ5IHtcclxuXHRkYXRlOiBzdHJpbmdcclxuXHRpbnRlbnNpdHk/OiBudW1iZXJcclxuXHRjb2xvcj86IHN0cmluZyB8IG51bWJlclxyXG5cdGNvbnRlbnQ/OiBzdHJpbmdcclxufVxyXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBDYWxlbmRhckRhdGEgPSB7XHJcblx0eWVhcjogbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLFxyXG5cdGNvbG9yczoge1xyXG5cdFx0ZGVmYXVsdDogW1wiI2M2ZTQ4YlwiLCBcIiM3YmM5NmZcIiwgXCIjNDlhZjVkXCIsIFwiIzJlODg0MFwiLCBcIiMxOTYxMjdcIixdLFxyXG5cdH0sXHJcblx0ZW50cmllczogW3sgZGF0ZTogXCIxOTAwLTAxLTAxXCIsIH0sXSxcclxuXHRzaG93Q3VycmVudERheUJvcmRlcjogdHJ1ZSxcclxuXHRkZWZhdWx0RW50cnlJbnRlbnNpdHk6IDQsXHJcblx0aW50ZW5zaXR5U2NhbGVTdGFydDogMSxcclxuXHRpbnRlbnNpdHlTY2FsZUVuZDogNSxcclxufVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWF0bWFwQ2FsZW5kYXIgZXh0ZW5kcyBQbHVnaW4ge1xyXG5cclxuXHRzZXR0aW5nczogQ2FsZW5kYXJEYXRhXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtYW55IGRheXMgaW50byB0aGUgeWVhciB0aGUgc3VwcGxpZWQgZGF0ZSBpcy4gXHJcblx0ICogRXhhbXBsZTogZmlyc3Qgb2YgamFudWFyeSBpcyAxLCB0aGlyZCBvZiBmZWJydWFyeSBpcyAzNCAoMzErMykgXHJcblx0ICogQHBhcmFtIGRhdGVcclxuXHQgKi9cclxuXHRnZXRIb3dNYW55RGF5c0ludG9ZZWFyKGRhdGU6IERhdGUpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0KERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSkgLVxyXG5cdFx0XHRcdERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMCkpIC8gMjQgLyA2MCAvIDYwIC8gMTAwMFxyXG5cdFx0KVxyXG5cdH1cclxuXHRnZXRIb3dNYW55RGF5c0ludG9ZZWFyTG9jYWwoZGF0ZTogRGF0ZSk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKSAtXHJcblx0XHRcdFx0RGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKSkgLyAyNCAvIDYwIC8gNjAgLyAxMDAwXHJcblx0XHQpXHJcblx0fVxyXG5cdC8qKiBcclxuXHQgKiBrZWVwcyBIVE1MRWxlbWVudHMgcGFzc2VkIGFzIGNvbnRlbnQgZnJvbSByZW5kZXJpbmcgYWJvdmUgdGhlIGNhbGVuZGFyIGlmIHRoZXkgYXJlIG91dHNpZGUgb2YgdGhlIGRpc3BsYXllZCB5ZWFyXHJcblx0ICovXHJcblx0cmVtb3ZlSHRtbEVsZW1lbnRzTm90SW5ZZWFyKGVudHJpZXM6IEVudHJ5W10sIHllYXI6IG51bWJlciApe1xyXG5cdFx0XHRcdGNvbnN0IGNhbEVudHJpZXNOb3RJbkRpc3BsYXllZFllYXIgPSBlbnRyaWVzLmZpbHRlcihlPT5OdW1iZXIucGFyc2VJbnQoZS5kYXRlLnN1YnN0cmluZygwLDEwKSkhPT15ZWFyKSA/PyB0aGlzLnNldHRpbmdzLmVudHJpZXNcclxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdFx0XHRjYWxFbnRyaWVzTm90SW5EaXNwbGF5ZWRZZWFyLmZvckVhY2goZSA9PiBlLmNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlLmNvbnRlbnQucmVtb3ZlKCkpXHJcblx0fVxyXG5cclxuXHRjbGFtcChpbnB1dDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGlucHV0IDwgbWluID8gbWluIDogaW5wdXQgPiBtYXggPyBtYXggOiBpbnB1dFxyXG5cdH1cclxuXHJcblx0bWFwKGN1cnJlbnQ6IG51bWJlciwgaW5NaW46IG51bWJlciwgaW5NYXg6IG51bWJlciwgb3V0TWluOiBudW1iZXIsIG91dE1heDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IG1hcHBlZDogbnVtYmVyID0gKChjdXJyZW50IC0gaW5NaW4pICogKG91dE1heCAtIG91dE1pbikpIC8gKGluTWF4IC0gaW5NaW4pICsgb3V0TWluXHJcblx0XHRyZXR1cm4gdGhpcy5jbGFtcChtYXBwZWQsIG91dE1pbiwgb3V0TWF4KVxyXG5cdH1cclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKClcclxuXHJcblx0XHQvL0B0cy1pZ25vcmVcclxuXHRcdHdpbmRvdy5yZW5kZXJIZWF0bWFwQ2FsZW5kYXIgPSAoZWw6IEhUTUxFbGVtZW50LCBjYWxlbmRhckRhdGE6IENhbGVuZGFyRGF0YSk6IHZvaWQgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgeWVhciA9IGNhbGVuZGFyRGF0YS55ZWFyID8/IHRoaXMuc2V0dGluZ3MueWVhclxyXG5cdFx0XHRjb25zdCBjb2xvcnMgPSBjYWxlbmRhckRhdGEuY29sb3JzID8/IHRoaXMuc2V0dGluZ3MuY29sb3JzXHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLnJlbW92ZUh0bWxFbGVtZW50c05vdEluWWVhcihjYWxlbmRhckRhdGEuZW50cmllcywgeWVhcilcclxuXHRcdFx0XHJcblx0XHRcdGNvbnN0IGNhbEVudHJpZXMgPSBjYWxlbmRhckRhdGEuZW50cmllcy5maWx0ZXIoZT0+TnVtYmVyLnBhcnNlSW50KGUuZGF0ZS5zdWJzdHJpbmcoMCwxMCkpPT09eWVhcikgPz8gdGhpcy5zZXR0aW5ncy5lbnRyaWVzXHJcblxyXG5cdFx0XHRjb25zdCBzaG93Q3VycmVudERheUJvcmRlciA9IGNhbGVuZGFyRGF0YS5zaG93Q3VycmVudERheUJvcmRlciA/PyB0aGlzLnNldHRpbmdzLnNob3dDdXJyZW50RGF5Qm9yZGVyXHJcblxyXG5cdFx0XHRjb25zdCBkZWZhdWx0RW50cnlJbnRlbnNpdHkgPSBjYWxlbmRhckRhdGEuZGVmYXVsdEVudHJ5SW50ZW5zaXR5ID8/IHRoaXMuc2V0dGluZ3MuZGVmYXVsdEVudHJ5SW50ZW5zaXR5XHJcblxyXG5cdFx0XHRjb25zdCBpbnRlbnNpdGllcyA9IGNhbEVudHJpZXMuZmlsdGVyKGUgPT4gZS5pbnRlbnNpdHkpLm1hcChlID0+IGUuaW50ZW5zaXR5KVxyXG5cdFx0XHRjb25zdCBtaW5pbXVtSW50ZW5zaXR5ID0gaW50ZW5zaXRpZXMubGVuZ3RoID8gTWF0aC5taW4oLi4uaW50ZW5zaXRpZXMpIDogdGhpcy5zZXR0aW5ncy5pbnRlbnNpdHlTY2FsZVN0YXJ0XHJcblx0XHRcdGNvbnN0IG1heGltdW1JbnRlbnNpdHkgPSBpbnRlbnNpdGllcy5sZW5ndGggPyBNYXRoLm1heCguLi5pbnRlbnNpdGllcykgOiB0aGlzLnNldHRpbmdzLmludGVuc2l0eVNjYWxlRW5kXHJcblx0XHRcdGNvbnN0IGludGVuc2l0eVNjYWxlU3RhcnQgPSBjYWxlbmRhckRhdGEuaW50ZW5zaXR5U2NhbGVTdGFydCA/PyBtaW5pbXVtSW50ZW5zaXR5XHJcblx0XHRcdGNvbnN0IGludGVuc2l0eVNjYWxlRW5kID0gY2FsZW5kYXJEYXRhLmludGVuc2l0eVNjYWxlRW5kID8/IG1heGltdW1JbnRlbnNpdHlcclxuXHJcblx0XHRcdGNvbnN0IG1hcHBlZEVudHJpZXM6IEVudHJ5W10gPSBbXVxyXG5cdFx0XHRjYWxFbnRyaWVzLmZvckVhY2goZSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbmV3RW50cnkgPSB7XHJcblx0XHRcdFx0XHRpbnRlbnNpdHk6IGRlZmF1bHRFbnRyeUludGVuc2l0eSxcclxuXHRcdFx0XHRcdC4uLmUsXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnN0IGNvbG9ySW50ZW5zaXRpZXMgPSBjb2xvcnNbZS5jb2xvcl0gPz8gY29sb3JzW09iamVjdC5rZXlzKGNvbG9ycylbMF1dXHJcblx0XHRcdFx0Y29uc3QgbnVtT2ZDb2xvckludGVuc2l0aWVzID0gT2JqZWN0LmtleXMoY29sb3JJbnRlbnNpdGllcykubGVuZ3RoXHJcblx0XHRcdFx0bmV3RW50cnkuaW50ZW5zaXR5ID0gTWF0aC5yb3VuZCh0aGlzLm1hcChuZXdFbnRyeS5pbnRlbnNpdHksIGludGVuc2l0eVNjYWxlU3RhcnQsIGludGVuc2l0eVNjYWxlRW5kLCAxLCBudW1PZkNvbG9ySW50ZW5zaXRpZXMpKVxyXG5cdFx0XHRcdG1hcHBlZEVudHJpZXNbdGhpcy5nZXRIb3dNYW55RGF5c0ludG9ZZWFyKG5ldyBEYXRlKGUuZGF0ZSkpXSA9IG5ld0VudHJ5XHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHRjb25zdCBmaXJzdERheU9mWWVhciA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIDAsIDEpKVxyXG5cdFx0XHRsZXQgbnVtYmVyT2ZFbXB0eURheXNCZWZvcmVZZWFyQmVnaW5zID0gKGZpcnN0RGF5T2ZZZWFyLmdldFVUQ0RheSgpICsgNikgJSA3XHJcblxyXG5cdFx0XHRpbnRlcmZhY2UgQm94IHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcblx0XHRcdFx0ZGF0ZT86IHN0cmluZztcclxuXHRcdFx0XHRjb250ZW50Pzogc3RyaW5nO1xyXG5cdFx0XHRcdGNsYXNzTmFtZXM/OiBzdHJpbmdcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgYm94ZXM6IEFycmF5PEJveD4gPSBbXVxyXG5cclxuXHRcdFx0d2hpbGUgKG51bWJlck9mRW1wdHlEYXlzQmVmb3JlWWVhckJlZ2lucykge1xyXG5cdFx0XHRcdGJveGVzLnB1c2goeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIiwgfSlcclxuXHRcdFx0XHRudW1iZXJPZkVtcHR5RGF5c0JlZm9yZVllYXJCZWdpbnMtLVxyXG5cdFx0XHR9XHJcblx0XHRcdGNvbnN0IGxhc3REYXlPZlllYXIgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAxMSwgMzEpKVxyXG5cdFx0XHRjb25zdCBudW1iZXJPZkRheXNJblllYXIgPSB0aGlzLmdldEhvd01hbnlEYXlzSW50b1llYXIobGFzdERheU9mWWVhcikgLy9lZyAzNjUgb3IgMzY2XHJcblx0XHRcdGNvbnN0IHRvZGF5c0RheU51bWJlckxvY2FsID0gdGhpcy5nZXRIb3dNYW55RGF5c0ludG9ZZWFyTG9jYWwobmV3IERhdGUoKSlcclxuXHJcblx0XHRcdGZvciAobGV0IGRheSA9IDE7IGRheSA8PSBudW1iZXJPZkRheXNJblllYXI7IGRheSsrKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJveDogQm94ID0ge31cclxuXHJcblx0XHRcdFx0aWYgKGRheSA9PT0gdG9kYXlzRGF5TnVtYmVyTG9jYWwgJiYgc2hvd0N1cnJlbnREYXlCb3JkZXIpIGJveC5jbGFzc05hbWVzID0gXCJ0b2RheVwiXHJcblxyXG5cdFx0XHRcdGlmIChtYXBwZWRFbnRyaWVzW2RheV0pIHtcclxuXHRcdFx0XHRcdGNvbnN0IGVudHJ5ID0gbWFwcGVkRW50cmllc1tkYXldXHJcblxyXG5cdFx0XHRcdFx0Ym94LmRhdGUgPSBlbnRyeS5kYXRlXHJcblxyXG5cdFx0XHRcdFx0aWYgKGVudHJ5LmNvbnRlbnQpIGJveC5jb250ZW50ID0gZW50cnkuY29udGVudFxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnREYXlDb2xvcnMgPSBlbnRyeS5jb2xvciA/IGNvbG9yc1tlbnRyeS5jb2xvcl0gOiBjb2xvcnNbT2JqZWN0LmtleXMoY29sb3JzKVswXV1cclxuXHRcdFx0XHRcdGJveC5iYWNrZ3JvdW5kQ29sb3IgPSBjdXJyZW50RGF5Q29sb3JzW2VudHJ5LmludGVuc2l0eSAtIDFdXHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRib3hlcy5wdXNoKGJveClcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyR3JhcGhEaXYgPSBjcmVhdGVEaXYoe1xyXG5cdFx0XHRcdGNsczogXCJoZWF0bWFwLWNhbGVuZGFyLWdyYXBoXCIsXHJcblx0XHRcdFx0cGFyZW50OiBlbCxcclxuXHRcdFx0fSlcclxuXHJcblx0XHRcdGNyZWF0ZURpdih7XHJcblx0XHRcdFx0Y2xzOiBcImhlYXRtYXAtY2FsZW5kYXIteWVhclwiLFxyXG5cdFx0XHRcdHRleHQ6IFN0cmluZyh5ZWFyKS5zbGljZSgyKSxcclxuXHRcdFx0XHRwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckdyYXBoRGl2LFxyXG5cdFx0XHR9KVxyXG5cclxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyTW9udGhzVWwgPSBjcmVhdGVFbChcInVsXCIsIHtcclxuXHRcdFx0XHRjbHM6IFwiaGVhdG1hcC1jYWxlbmRhci1tb250aHNcIixcclxuXHRcdFx0XHRwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckdyYXBoRGl2LFxyXG5cdFx0XHR9KVxyXG5cclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiSmFuXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkZlYlwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJNYXJcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiQXByXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIk1heVwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJKdW5cIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiSnVsXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIkF1Z1wiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJTZXBcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiT2N0XCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyTW9udGhzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIk5vdlwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhck1vbnRoc1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJEZWNcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJNb250aHNVbCwgfSlcclxuXHJcblx0XHRcdGNvbnN0IGhlYXRtYXBDYWxlbmRhckRheXNVbCA9IGNyZWF0ZUVsKFwidWxcIiwge1xyXG5cdFx0XHRcdGNsczogXCJoZWF0bWFwLWNhbGVuZGFyLWRheXNcIixcclxuXHRcdFx0XHRwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckdyYXBoRGl2LFxyXG5cdFx0XHR9KVxyXG5cclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiTW9uXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyRGF5c1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJUdWVcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJEYXlzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIldlZFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiVGh1XCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyRGF5c1VsLCB9KVxyXG5cdFx0XHRjcmVhdGVFbChcImxpXCIsIHsgdGV4dDogXCJGcmlcIiwgcGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJEYXlzVWwsIH0pXHJcblx0XHRcdGNyZWF0ZUVsKFwibGlcIiwgeyB0ZXh0OiBcIlNhdFwiLCBwYXJlbnQ6IGhlYXRtYXBDYWxlbmRhckRheXNVbCwgfSlcclxuXHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7IHRleHQ6IFwiU3VuXCIsIHBhcmVudDogaGVhdG1hcENhbGVuZGFyRGF5c1VsLCB9KVxyXG5cclxuXHRcdFx0Y29uc3QgaGVhdG1hcENhbGVuZGFyQm94ZXNVbCA9IGNyZWF0ZUVsKFwidWxcIiwge1xyXG5cdFx0XHRcdGNsczogXCJoZWF0bWFwLWNhbGVuZGFyLWJveGVzXCIsXHJcblx0XHRcdFx0cGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJHcmFwaERpdixcclxuXHRcdFx0fSlcclxuXHJcblx0XHRcdGJveGVzLmZvckVhY2goZSA9PiB7XHJcblx0XHRcdFx0Y3JlYXRlRWwoXCJsaVwiLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiBlLmNvbnRlbnQsXHJcblx0XHRcdFx0XHRhdHRyOiB7XHJcblx0XHRcdFx0XHRcdC4uLmUuYmFja2dyb3VuZENvbG9yICYmIHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2UuYmFja2dyb3VuZENvbG9yfTtgLCB9LFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdGNsczogZS5jbGFzc05hbWVzLFxyXG5cdFx0XHRcdFx0cGFyZW50OiBoZWF0bWFwQ2FsZW5kYXJCb3hlc1VsLFxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSlcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncylcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUF3QjtBQXFCeEIsSUFBTSxtQkFBaUM7QUFBQSxFQUN0QyxNQUFNLElBQUksT0FBTztBQUFBLEVBQ2pCLFFBQVE7QUFBQSxJQUNQLFNBQVMsQ0FBQyxXQUFXLFdBQVcsV0FBVyxXQUFXO0FBQUE7QUFBQSxFQUV2RCxTQUFTLENBQUMsRUFBRSxNQUFNO0FBQUEsRUFDbEIsc0JBQXNCO0FBQUEsRUFDdEIsdUJBQXVCO0FBQUEsRUFDdkIscUJBQXFCO0FBQUEsRUFDckIsbUJBQW1CO0FBQUE7QUFFcEIsb0NB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
